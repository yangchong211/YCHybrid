#### 目录介绍
- 01.flutter和原生之间交互
- 02.MethodChanel流程
- 03.MethodChanel使用流程
- 04.MethodChanel代码实践
- 05.EventChannel流程
- 06.EventChannel基本流程
- 07.EventChannel代码实现
- 08.BasicMessageChannel流程
- 09.BasicMessageChannel基本流程
- 10.BasicMessageChannel代码实现
- 11.Channel通信传递稳定性
- 12.onActivityResult如何实现




### 需要阅读
- Android与Flutter之间的通信：https://juejin.cn/post/6844903873358856200
- 深入理解Flutter Platform Channel： https://developer.aliyun.com/article/630105


### 01.flutter和原生之间交互
- flutter可以与native之间进行通信，帮助我们使用native提供的能力。
    - 通信是双向的，我们可以从Native层调用flutter层的dart代码，同时也可以从flutter层调用Native的代码。
- 我们需要使用Platform Channels APIs进行通信，主要包括下面三种：
    - MethodChannel：用于传递方法调用（method invocation）
    - EventChannel：用于事件流的发送（event streams）
    - BasicMessageChannel：用于传递字符串和半结构化的消息
- channel通信是异步还是同步的
    - 为了保证用户界面在交互过程中的流畅性，无论是从Flutter向Native端发送消息，还是Native向Flutter发送消息都是以异步的形式进行传递的。
- 几种channel应用场景分析
    - MethodChannel使用场景：无论是Flutter端还是Native端都可以通过MethodChannel向对方平台发送两端提前定义好的方法名来调用对方平台相对应的消息处理逻辑并且带回返回值给被调用方。
    - EventChannel的使用场景：更侧重于Native平台主动向Flutter平台，单向给Flutter平台发送消息，Flutter无法返回任何数据给Native端，EventChannel描述是单通的。可以类比Android里面的广播……
    - BasicMessageChannel的使用场景：比如flutter想拍照，拍完照后的图片路径需要传给flutter，照片的路径发送可以使用BasicMessageChannel.Reply回复，也可以使用sendMessage主动再发一次消息。个人认为接收消息并回复消息属于一次通信，所以倾向于使用BasicMessageChannel.Reply。
- 混合开发通常用那种channel
    - 只是混合开发通常涉及到两端频繁通信，个人更加倾向使用BasicMessageChannel，不分主客，使用和通信更方便。


### 02.MethodChannel流程
- 其中最常用的是MethodChanel，MethodChanel的使用与在Android的JNI调用非常类似，但是MethodChanel更加简单，而且相对于JNI的同步调用MethodChanel的调用是异步的：
    - ![image](https://img-blog.csdnimg.cn/20200210120835317.png)
- 从flutter架构图上可以看到，flutter与native的通信发生在Framework和Engine之间，framewrok内部会将MethodChannel以BinaryMessage的形式与Engine进行数据交换。




### 03.MethodChanel使用流程
#### 3.1 flutter调用native
- flutter调用native步骤
    - [native] 使用MethodChannel#setMethodCallHandler注册回调
    - [flutter] 通过MethodChannel#invokeMethod发起异步调用
    - [native] 调用native方法通过Result#success 返回Result，出错时返回error
    - [flutter] 收到native返回的Result
- 如图所示
    - ![image](https://img-blog.csdnimg.cn/20200210123241854.png)


#### 3.2 native调用flutter
- native调用flutter
    - 与flutter调用native的顺序完全一致，只是[native]与[flutter]角色反调
- 如图所示
    - ![image](https://img-blog.csdnimg.cn/20200210123803438.png)
- NA端使用MethodChannel
    - 首先定义Channel名称，需要保证是唯一的，在Flutter端需要使用同样的名称来创建MethodChannel。如果名称不一样，则会导致匹配不上……
    - 第一个参数：是messenger，类型是BinaryMessenger，是一个接口，代表消息信使，是消息发送与接收的工具；
    - 第二个参数：是name，就是Channel名称，和flutter定义的要一样；
    - 第三个参数：是codec，类型是MethodCodec，代表消息的编解码器，如果没有传该参数，默认使用StandardMethodCodec。



### 04.MethodChanel代码实践
#### 4.1 native调用flutter
- 定义好了MethodChannel之后调用setMethodCallHandler()方法设置消息处理回调，参数是MethodHandler类型，需要实现它的onMethodCall()方法。onMethodCall()方法有两个参数methodCall和result，methodCall记录了调用的方法信息，包括方法名和参数，result用于方法的返回值，可以通过result.success()方法返回信息给Flutter端。
    ```
    private void createChannel() {
        nativeChannel = new EventChannel(binaryMessenger, EVENT_CHANNEL, StandardMethodCodec.INSTANCE);
        // 注册Handler实现
        nativeChannel.setStreamHandler(new EventChannel.StreamHandler() {
            @Override
            public void onListen(Object arguments, EventChannel.EventSink events) {
                String android = "逗比，来自android原生的参数";
                events.success(android);
            }

            @Override
            public void onCancel(Object arguments) {

            }
        });
    }
    ```
-  可以通过invokeMethod方法让NA执行调用flutter方法。那么执行了flutter方法后需要回传数据，这个时候就需要用到Result接口呢，代码如下所示：
    ```
    HashMap<String , String> map = new HashMap<>();
    map.put("invokeKey","你好，这个是从NA传递过来的数据");
    //nativeChannel.resizeChannelBuffer(100);
    nativeChannel.invokeMethod("getFlutterResult", map , new MethodChannel.Result() {
        @SuppressLint("SetTextI18n")
        @Override
        public void success(@Nullable Object result) {
            tvContent.setText("测试内容："+result);
        }

        @SuppressLint("SetTextI18n")
        @Override
        public void error(String errorCode, @Nullable String errorMessage, @Nullable Object errorDetails) {
            tvContent.setText("测试内容：flutter传递给na数据传递错误");
        }

        @Override
        public void notImplemented() {

        }
    });
    ```
- 事件接收处理端
    - 接收处理回调时onMethodCall(MethodCall call, MethodChannel.Result result)通过methodCall接收事件发送者传递回来的信息，通过Result把处理完的结果发送给事件发送方。
    - 通过methodCall.method：来区分不同函数名（方法）名以执行不同的业务逻辑，
    - 通过methodCall.hasArgument（"key"）：判断是否有某个key对应的value
    - 通过methodCall.argument（"key"）：获取key对应的value值
    - 通过result.success(object)：把处理完的结果返回给事件发送方
- 事件发送端
    - 处理事件发送方通过methodChannel.invokeMethod("方法名","要传递的参数")把需要传递的参数传递给事件监听者。 其中
    - 方法名:不能为空
    - 要传递的参数:可以为空，若不为空则必须为可Json序列化的对象。
    - callback：可以为空，若不为空则表示执行了flutter方法后的回调监听状态


#### 4.2 flutter调用native
- Flutter使用MethodChannel
    - 在Flutter端同样需要定义一个MethodChannel，使用MethodChannel需要引入services.dart包，Channel名称要和Android端定义的相同。
    ```
    static const method = const MethodChannel('com.ycbjie.android/method');
    ```
- 添加监听NA调用flutter方法的监听，flutter代码是setMethodCallHandler方法实现。return则表示flutter回传给NA的数据操作。
    ```
      method.setMethodCallHandler(nativeCallHandler);

      // 注册方法，等待被原生通过invokeMethod唤起
      Future<dynamic> nativeCallHandler(MethodCall methodCall) async {
        switch (methodCall.method) {
          case "getFlutterResult":
          //获取参数
            String paramsFromNative = await methodCall.arguments["invokeKey"];
            print("原生android传递过来的参数为------ $paramsFromNative");
            return "你好，这个是从flutter回传给NA的数据";
            break;
        }
      }
    ```
- flutter是如何给NA发送消息的呢，直接调用invokeMethod方法，代码如下所示
    ```
      Future<Null> _jumpToNativeWithParams1() async {
        Map<String, String> map = { "flutter": "这是一条来自flutter的参数" };
        String result = await method.invokeMethod('android', map);
        print(result);
      }
    ```


### 05.EventChannel流程
- EventChannel用于从native向flutter发送通知事件，例如flutter通过其监听Android的重力感应变化等。与MethodChannel不同，EventChannel是native到flutter的单向调用，调用是多播（一对多）的，可以类比成Android的Brodecast。


### 06.EventChannel基本流程
- 照例先看一下API使用的基本流程：
    - [native]EventChannel#setStreamHandler注册Handler实现
    - [native]EventChannel初始化结束后，在StreamHandler#onLister回调中获取EventSink引用并保存
    - [flutter]EventChannel#receiveBroadcastStream注册listener，建立监听
    - [native]使用EventSink#sucess发送通知事件
    - [flutter]接受到事件通知
    - [native]通知结束时调用endOfStream结束
- 如图所示
    - ![image](https://img-blog.csdnimg.cn/20200210203415309.png)



### 07.EventChannel代码实现
- flutter端
    - 创建EventChannel，注册“包名/标识符”的channel名
    - 通过StreamSubscription#listen注册listener，其中cancelOnError参数表示遇到错误时是否自动结束监听
    ```
    class _MyHomePageState extends State<MyHomePage> {
      static const EventChannel _channel = const EventChannel('com.example.eventchannel/interop');

      StreamSubscription _streamSubscription;
      String _platformMessage;

      void _enableEventReceiver() {
        _streamSubscription = _channel.receiveBroadcastStream().listen(
            (dynamic event) {
              print('Received event: $event');
              setState(() {
                _platformMessage = event;
              });
            },
            onError: (dynamic error) {
              print('Received error: ${error.message}');
            },
            cancelOnError: true);
      }

      void _disableEventReceiver() {
        if (_streamSubscription != null) {
          _streamSubscription.cancel();
          _streamSubscription = null;
        }
      }

      @override
      initState() {
        super.initState();
        _enableEventReceiver();
      }

      @override
      void dispose() {
        super.dispose();
        _disableEventReceiver();
      }
    ```
- native(android)端
    - 通过EventChannel#setStreamHandler注册Handler实现
    - 初始化完成后，获取eventSink引用并保存
    - eventSink发送事件通知
    - 通知结束时调用event#endOfStream，此时onCancel会被调用
    - 必要时，可通过evnetSink#error发送错误通知，flutter的StreamSubscription#onError会收到通知
    ```
    class MainActivity: FlutterActivity() {
        private lateinit var channel: EventChannel
        var eventSink: EventSink? = null

        override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
            GeneratedPluginRegistrant.registerWith(flutterEngine)

            channel = EventChannel(flutterEngine.dartExecutor.binaryMessenger, "com.example.eventchannel/interop")
            channel.setStreamHandler(
                    object : StreamHandler {
                        override fun onListen(arguments: Any?, events: EventSink) {
                            eventSink = events
                            Log.d("Android", "EventChannel onListen called")
                            Handler().postDelayed({
                                eventSink?.success("Android")
                                //eventSink?.endOfStream()
                                //eventSink?.error("error code", "error message","error details")
                            }, 500)
                        }
                        override fun onCancel(arguments: Any?) {
                            Log.w("Android", "EventChannel onCancel called")
                        }
                    })
        }
    }
    ```


### 08.BasicMessageChannel流程
- BasicMessageChannel用于在flutter和native互相发送消息，一方给另一方发送消息，收到消息之后给出回复。


### 09.BasicMessageChannel基本流程
- flutter向native发送消息
    - [flutter]创建BasicMessageChannel
    - [native]通过BasicMessageChannel#MessageHandler注册Handler
    - [flutter]通过BasicMessageChannel#send发送消息
    - [native]BasicMessageChannel#MessageHandler#onMessage中接收消息，然后reply
- 如图所示
    - ![image](https://img-blog.csdnimg.cn/20200211122018729.png)
- native向flutter发送消息
    - 流程也是一样的，只是将[flutter]与[native]反调
- 如图所示
    - ![image](https://img-blog.csdnimg.cn/20200211123658306.png)


### 10.BasicMessageChannel代码实现
#### 10.1flutter端
- flutter需要完成以下工作
    - 创建BasicMessageChannel
    - 通过BasicMessageChannel#send发送消息
- 相对与其他Channel类型的创建，MessageChannel的创建除了channel名以外，还需要指定编码方式：
    ```
    BasicMessageChannel(String name, MessageCodec<T> codec, {BinaryMessenger binaryMessenger})
    ```
- 发送的消息会以二进制的形式进行处理，所以要针对不同类型的数进行二进制编码
    - 编码类型	消息格式
    - BinaryCodec	发送二进制消息时
    - JSONMessageCodec	发送Json格式消息时
    - StandardMessageCodec	发送基本型数据时
    - StringCodec	发送String类型消息时
- 代码
    ```
    class _MyHomePageState extends State<MyHomePage> {
      static const _channel = BasicMessageChannel('com.example.messagechannel/interop', StringCodec());

      String _platformMessage;

      void _sendMessage() async {
        final String reply = await _channel.send('Hello World form Dart');
        print(reply);
      }

      @override
      initState() {
        super.initState();

        // Receive messages from platform
        _channel.setMessageHandler((String message) async {
          print('Received message = $message');
          setState(() => _platformMessage = message);
          return 'Reply from Dart';
        });

        // Send message to platform
        _sendMessage();
      }
    ```


#### 10.2 native(android)端
- android端完成以下工作：
    - 创建BasicMessageChannel
    - 通过setHandler注册MessageHandler
    - MessageHandler#onMessage回调中接收到message后，通过reply进行回复
- 代码
    ```
    class MainActivity: FlutterActivity() {
        override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
            GeneratedPluginRegistrant.registerWith(flutterEngine)

            val channel = BasicMessageChannel(
                    flutterEngine.dartExecutor.binaryMessenger,
                    "com.example.messagechannel/interop",
                    StringCodec.INSTANCE)

            // Receive messages from Dart
            channel.setMessageHandler { message, reply ->
                Log.d("Android", "Received message = $message")
                reply.reply("Reply from Android")
            }

            // Send message to Dart
            Handler().postDelayed({
                channel.send("Hello World from Android") { reply ->
                    Log.d("Android", "$reply")
                }
            }, 500)
        }
    }
    ```


### 11.Channel通信传递稳定性
- channel传递数据是否会丢失
    - 如何测试
- 传递数据是否稳定
    - todo 测试


### 12.onActivityResult如何实现
- 先说一个场景
    - 在开发中我们经常会遇到关闭当前页面的同时返回给上一个页面数据的场景，在Android中是通过startActivityForResult和onActivityResult()实现的。
    - 而纯Flutter页面之间可以通过在Navigator.of(context).pop()方法中添加参数来实现，那么对于Flutter页面和Android原生页面之间如何在返回上一页时传递数据呢，通过MethodChannel就可以实现。


#### 12.1 Flutter页面返回Android原生页面
- 在Flutter端调用原生的返回方法就可以了，首先在Flutter页面添加一个按钮，点击按钮返回原生页面，代码如下：
    ```
    new Padding(
        padding: const EdgeInsets.only(
            left: 10.0, top: 10.0, right: 10.0),
        child: new RaisedButton(
            textColor: Colors.black,
            child: new Text('返回上一界面，并携带数据'),
            onPressed: () {
                Map<String, dynamic> map = {'message': '我从Flutter页面回来了'};
                String result = await method.invokeMethod('goBackWithResult', map);
            }),
      ),
    ```
- Android端依然是通过判断methodCall.method的值来执行指定的代码，通过methodCall.argument()获取Flutter传递的参数。
    ```
    nativeChannel.setMethodCallHandler(new MethodChannel.MethodCallHandler() {
        @Override
        public void onMethodCall(@NonNull MethodCall methodCall, @NonNull MethodChannel.Result result) {
            if ("goBackWithResult".equals(methodCall.method)) {
                // 返回上一页，携带数据
                Intent backIntent = new Intent();
                backIntent.putExtra("message", (String) methodCall.argument("message"));
                setResult(RESULT_OK, backIntent);
                finish();
            }
        }
    });
    ```

#### 12.2 Android原生页面返回Flutter页面
- Android原生页面返回Flutter页面
    - 这种情况需要原生来调用Flutter代码，和Flutter调用原生方法的步骤是一样的。首先触发flutter页面按钮，从flutter跳转na页面，然后触发na页面返回操作，返回到Flutter页面，并传递数据。
- 首先是flutter页面触发跳转到na页面的代码操作逻辑，代码如下所示
    ```
    //flutter
      new Padding(
        padding: const EdgeInsets.only(left: 10.0, top: 10.0, right: 10.0),
        child: new RaisedButton(
            textColor: Colors.black,
            child: new Text('跳转到原生逗比界面，回调结果：$_methodResult1'),
            onPressed: () {
              _jumpToNative();
            }),
      ),

    //na，注意na接收到flutter指令后，na是调用startActivityForResult操作跳转到na的新页面
    nativeChannel.setMethodCallHandler(new MethodChannel.MethodCallHandler() {
        @Override
        public void onMethodCall(@NonNull MethodCall methodCall, @NonNull MethodChannel.Result result) {
            if ("doubi".equals(methodCall.method)) {
                //接收来自flutter的指令
                //跳转到指定Activity
                Intent intent = new Intent(MethodChannelActivity.this, MethodResultActivity.class);
                startActivityForResult(intent,RESULT_OK2);
                //返回给flutter的参数
                result.success("Na收到指令");
            }
        }
    });
    ```
- 然后接下来的一步是，从NA返回到flutter页面，然后再去调用flutter方法。具体操作代码如下所示
    ```
    //na flutter触发打开na的新的页面
    public class MethodResultActivity extends AppCompatActivity {

        @SuppressLint("SetTextI18n")
        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_android);
            TextView tv = findViewById(R.id.tv);
            tv.setText("flutter页面打开NA页面，测试Android原生页面返回Flutter页面");
            tv.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    Intent intent = new Intent();
                    intent.putExtra("message", "我从原生页面回来了");
                    setResult(RESULT_OK2, intent);
                    finish();
                }
            });
        }
    }

    // na flutter承载容器的na的原生页面
    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (data != null && resultCode==RESULT_OK2) {
            // MethodResultActivity返回的数据
            String message = data.getStringExtra("message");
            Map<String, Object> result = new HashMap<>();
            result.put("message", message);
            // 调用Flutter端定义的方法
            nativeChannel.invokeMethod("onActivityResult", result, new MethodChannel.Result() {
                @SuppressLint("SetTextI18n")
                @Override
                public void success(@Nullable Object result) {
                    tvContent.setText("测试内容2："+result);
                }

                @SuppressLint("SetTextI18n")
                @Override
                public void error(String errorCode, @Nullable String errorMessage, @Nullable Object errorDetails) {
                    tvContent.setText("测试内容：flutter传递给na数据传递错误2");
                }

                @Override
                public void notImplemented() {

                }
            });
        }
    }

    //flutter
      Future<dynamic> handler(MethodCall call) async {
        switch (call.method) {
          case 'onActivityResult':
            // 获取原生页面传递的参数
            print(call.arguments['message']);
            return "你好，这个是从flutter传递过来的数据";
        }
      }

      flutterChannel.setMethodCallHandler(handler);
    ```







