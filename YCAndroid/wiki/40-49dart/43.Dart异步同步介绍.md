#### 目录介绍
- 01.Future简单介绍
    - 1.1 普通异步案例
    - 1.2 耗时异步案例
- 02.async/await介绍
- 03.看一个案例
- 04.先看一个案例






### 01.Future简单介绍
- async 库中有一个叫Future的东西。Future是基于观察者模式的。如果你熟悉Rx或者JavaScript的Promises，你就很容易明白了。
    - 首先先看一下下面的案例，看看它们之间有什么区别？
    ```
      void testA() async{
        new Future<String>(() {
          return "This is a doubi";
        });
      }
    
      Future testB() async{
        return new Future<String>(() {
          return "This is a doubi";
        });
      }
    
      Future<String> testC() {
        return new Future<String>(() {
          return "This is a doubi";
        });
      }
    ```


#### 1.1 普通异步案例
- Future是支持泛型的，例如Future,通过T指定将来返回值的类型。
    - 定义了一个叫getTest的函数，返回值为Future<String>.你可以通过new关键字创建一个Future。
    - Future的构造函数，需要一个函数作为参数，这个函数返回T类型的数据。在匿名函数中的返回值就是Future的返回值。
- 当调用了getTest方法，他返回Future<String>.我们通过调用then方法订阅Future，在then中注册回调函数，当Future返回值时调用注册函数。同时注册了catchError方法处理在Future执行之间发生的异常。这个例子中不会发生异常。
    ```
      void test() {
        getTest().then((value) {
          print("测试----------"+value);
        }).catchError((error) {
          print('测试----------Error');
        });
      }
    
      Future<String> getTest() {
        return new Future<String>(() {
          return "This is a doubi";
        });
      }
      
      //打印结果
      2019-06-21 17:11:12.941 16501-16583/com.hwmc.auth I/flutter: 测试----------This is a doubi
    ```
- 下面这个案例会发生异常
    ```
      void test() {
        getTest().then((value) {
          print("测试----------"+value);
        }).catchError((error) {
          print('测试----------Error');
        });
      }
    
      Future<String> getTest() {
        return new Future<String>(() {
          return "This is a doubi";
        });
      }
      
      //打印结果
      2019-06-21 17:18:46.896 16501-16583/com.hwmc.auth I/flutter: 测试----------Error
    ```


#### 1.2 耗时异步案例
- 在生产环境中都是一些耗时的操作，例如，网络调用，我们可以使用Future.delayed()模仿。
    - 现在如果你运行，你将需要2秒，才能返回结果。
    ```
      void test() {
        getTest().then((value) {
          print("测试----------"+value);
        }).catchError((error) {
          print('测试----------Error');
        });
      }
    
      Future<String> getTest() {
        return new Future<String>.delayed(new Duration(milliseconds: 2000),() {
          return "This is a doubi";
        });
      }
    ```
    - 接下来再看一个案例。在调用函数之后，我们添加了print语句。在这种场景中，print语句会先执行，之后future的返回值才会打印。这是future的预期行为.但是如果我们希望在执行其他语句之前，先执行future。
    ```
      void test() {
        getTest().then((value) {
          print("测试----------"+value);
        }).catchError((error) {
          print('测试----------Error');
        });
        print('测试----------逗比是这个先执行吗');
      }
    
      Future<String> getTest() {
        return new Future<String>.delayed(new Duration(milliseconds: 2000),() {
          return "This is a doubi";
        });
      }
      
      2019-06-21 17:26:16.619 16501-16583/com.hwmc.auth I/flutter: 测试----------逗比是这个先执行吗
      2019-06-21 17:26:17.176 16501-16583/com.hwmc.auth I/flutter: 测试----------This is a doubi
    ```



### 02.async/await介绍
- 思考一下，看了上面的案例，对于future的预期行为，如果我们希望在执行其他语句之前，先执行future，该怎么操作呢？
    - 这就需要用到需要用到async/await。使用await关键字，必须给函数添加async关键字，否则没有效果。
    - 注意：要使用 await，其方法必须带有 async 关键字。可以使用 try, catch, 和 finally 来处理使用 await 的异常！
- 测试案例代码如下
    ```
    /*模拟异步加载用户信息*/
    Future _getUserInfo() async{
      await new Future.delayed(new Duration(milliseconds: 3000));
      return "我是用户杨充";
    }
     
    /*加载用户信息，顺便打印时间看看顺序*/
    Future _loadUserInfo() async{
      print("_loadUserInfo:${new DateTime.now()}");
      print(await _getUserInfo());
      print("_loadUserInfo:${new DateTime.now()}");
    }
    ```
- 在test中调用该方法：
    ```
    void test(){
        print("test:${new DateTime.now()}");
        _loadUserInfo();
        print("test:${new DateTime.now()}");
    }
    ```
- 打印结果如下：
    ```
    I/flutter ( 1802): test:2019-06-20 09:46:40.097339
    I/flutter ( 1802): _loadUserInfo:2019-06-20 09:46:40.103542
    I/flutter ( 1802): Instance of 'Future<dynamic>'
    I/flutter ( 1802): test:2019-06-20 09:46:40.108510
    I/flutter ( 1802): 我是用户杨充
    I/flutter ( 1802): _loadUserInfo:2019-06-20 09:46:43.117136
    ```
- 得出结论
    - 很明显，打印结果并没有按照串联的方式依次打印。flutter中会改造带asyc关键字的方法，让这个方法脱离主流程，变成“后面一点”执行（通过scheduleMicrotask)，所以可以让我们的程序“看起来”是顺序执行的。


### 03.Future api
- 修改一下 loadUserInfo() 方法：
    ```
    /*加载用户信息，顺便打印时间看看顺序*/
    Future _loadUserInfo() async{
        print("_loadUserInfo:${new DateTime.now()}");
        _getUserInfo().then((info){
          print(info);
        });
        print("_loadUserInfo:${new DateTime.now()}");
    }
    ```
- 再次运行输出一下：
    ```
    I/flutter ( 1802): initState:2019-06-20 09:50:32.488765
    I/flutter ( 1802): _loadUserInfo:2019-06-20 09:50:32.494751
    I/flutter ( 1802): _loadUserInfo:2019-06-20 09:50:32.499725
    I/flutter ( 1802): Instance of 'Future<dynamic>'
    I/flutter ( 1802): initState:2019-06-20 09:50:32.499970
    I/flutter ( 1802): 我是用户
    ```
- 两次输出是有不同的，主要不同在于第二个 loadUserInfo 的日志打印，与‘我是用户’的输出顺序，为什么有差异？
- await会阻塞流程，等待紧跟着的的Future执行完毕之后，再执行下一条语句，而如果用了Future.then这个api，那么就不会等待，直接执行下面的语句，等Future执行完了，再调用then这个方法。




### 03.看一个案例
- 一个 async 方法 是函数体被标记为 async 的方法。 虽然异步方法的执行可能需要一定时间，但是 异步方法立刻返回 - 在方法体还没执行之前就返回了。
    ```
    void getHttp async {
        // TODO ---
    }
    ```
    - 在一个方法上添加 async 关键字，则这个方法返回值为 Future。 
        - 例如，下面是一个返回字符串的同步方法：
        ```
        String loadAppVersion() => "1.0.2"
        ```
    - 使用 async 关键字，则该方法返回一个 Future，并且 认为该函数是一个耗时的操作。
        ```
        Futre<String> loadAppVersion() async  => "1.0.2"
        ```
    - 注意，方法的函数体并不需要使用 Future API。 Dart 会自动在需要的时候创建 Future 对象。
- 好的代码是这样的
    ```
    void main() {
     //调用异步方法
     doAsync();
    }
    
    // 在函数上声明了 async 表明这是一个异步方法
    Future<bool> doAsync() async {
      try {
        // 这里是一个模拟请求一个网络耗时操作
        var result = await getHttp();
        //请求出来的结果
        return printResult(result);
      } catch (e) {
        print(e);
        return false;
      }
    }
    //将请求出来的结果打印出来
    Future<bool> printResult(summary) {
      print(summary);
    }
    
    //开始模拟网络请求 等待 5 秒返回一个字符串
    getHttp() {
     return new Future.delayed(Duration(seconds: 5), () => "Request Succeeded");
    }
    ```
- 不好的写法
    ```
    void main() {
     doAsync();
    }
    
    Future<String> doAsync() async {
        return  getHttp().then((r){
          return printResult(r);
        }).catchError((e){
          print(e);
        });
    }
    
    Future<String> printResult(summary) {
      print(summary);
    }
    
    Future<String> getHttp() {
     return new Future.delayed(Duration(seconds: 5), () => "Request Succeeded");
    }
    ```





### 04.先看一个案例
- 先来看一个案例
    ```
      void doAsyncs() async{
        //then catchError whenComplete
        new Future(() => futureTask()) //  异步任务的函数
            .then((m) => "1-:$m") //   任务执行完后的子任务
            .then((m) => print('2-$m')) //  其中m为上个任务执行完后的返回的结果
            .then((_) => new Future.error('3-:error'))
            .then((m) => print('4-'))
            .whenComplete(() => print('5-')) //不是最后执行whenComplete，通常放到最后回调
            .catchError((e) => print('6-catchError:' + e), test: (Object o) {
          print('7-:' + o);
          return true; //返回true，会被catchError捕获
        })
            .then((_) => new Future.error('11-:error'))
            .then((m) => print('10-'))
            .catchError((e) => print('8-:' + e))
        ;
      }
    
      futureTask() {
        return Future.delayed(Duration(seconds: 5),()  => "9-走去跑步");
      }
    ```
- 执行结果
    ```
    2019-06-21 18:34:21.937 16501-16583/com.hwmc.auth I/flutter: 2-1-:9-走去跑步
    2019-06-21 18:34:21.945 16501-16583/com.hwmc.auth I/flutter: 5-
    2019-06-21 18:34:21.948 16501-16583/com.hwmc.auth I/flutter: 7-:3-:error
    2019-06-21 18:34:21.952 16501-16583/com.hwmc.auth I/flutter: 6-catchError:3-:error
    2019-06-21 18:34:21.954 16501-16583/com.hwmc.auth I/flutter: 8-:11-:error
    ```
- 分析结果
    - 当异步函数 futureTask() 执行完会在内存中保存 ‘9-走去跑步’ 然后继续执行下一步 这个时候遇见了 then 现在会在内存中保存 “1-: 9-走去跑步 ”  继续执行 这个时候遇见了打印输出  2-1-:9-走去跑步 。现在第一个打印出来了。接着执行下一个 then() 这个时候遇见了一个 error 异常，Dart 会把这个异常保存在内存直到遇见捕获异常的地方。下面执行 whenComplete 这个函数 打印 5- 。然后遇见了一个捕获异常的函数 catchError 如果 test 返回 true ，会被 catchError 捕获 打印 7-:3-:error  6-catchError:3-:error。如果返回 false 只打印  7-:3-:error，会把 error 抛给下一个 catchError 。继续执行 又遇见了一个 error 11-:error ,现在出现 error 了  所以 then 10- 就不会执行了  。最后就直接捕获异常 打印 "8-11-error"。






















